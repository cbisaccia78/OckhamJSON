JSON grammar rules
    ws value ws 

Data Structures

    struct nAryTreeNode {
        char *jsonText;
        char *keyName;
        char *value; // should not be set until leaf node
        ValueType valueType;
        bool validSoFar;
        struct nAryTreeNode *children; 
    }
    typedef struct nAryTreeNode;

    struct DeSerializationTemplate {
        char *key;
        ValueType valueType;
        struct DeSerializationTemplate *children;
    }
    typedef struct DeSerializationTemplate {

    }

    struct Storage {

    };
    typedef struct Storage Storage;

Functions

//string functions

int stripTrailingLeadingWS(char *str)
    do it
    return integer offset from beginning of str*

//node validation functions

int nodeIsLeaf()

//node modification functions

int createRootValue(nAryTreeNode *root, char *rootJsonText){
    root->jsonText = rootJsonText;
    root->validSoFar = false;
    root->keyName = null;
    root->value = null;
    root->valueType = INVALID;
    root->children = null;
}


int parseKeyOffset(nAryTreeNode *node){
    node->jsonText = (node->jsonText + stripTrailingLeadingWS(nAryTreeNode->jsonText)) // pointer arithmetic
}

int parseKey(nAryTreeNode *node){
    do parse key
    nAryTreeNode->key = key;
}

int parseValueOffset(nAryTreeNode *node){

}

int parseValue(nAryTreeNode *node){
    do parse value
}


bool parse(nAryTreeNode *root, Template t){
    if(nodeIsLeaf(root)){
        parseKeyOffset(root);
        if(root->validSoFar){
            parseKey(root);
            if(root->validSoFar){
                if(root->key == t.key){
                    parseValueOffset(root);
                    if(root->validSoFar){
                        parseValue(root);
                        if(root->valueType != INVALID && root->valueType == t.valueType)
                            return root.isValid;
                    }
                }
                
            }
        }
        return false;
    }
    bool validChildren = true;
    for(child in root.children){
        validChildren = validChildren && parse(child, t)
    }
    return validChildren;
}

void _deserializeFromTemplate(nAryTreeNode root, Template t, Storage *s){

}


void deserializeFromTemplate(char *jsonText, Template t, Storage *s){
    //Create root node to represent top level JSON value
    nAryTreeNode *rootJSONValue;
    createRootValue(rootJSONValue, jsonText);

    //Parse JSON text using the help of the tree nodes
    bool parsedSuccessfully = parse(rootJSONValue, t);

    if(parsedSuccessfully){
        _deserializeFromTemplate(rootJSONValue, t, s);
    }
}


JSON cases from simplest to most complicated
    
    "ws" - invalid, must contain at least one object

    "\"\"" - empty string


Invalid JSON cases

    Unmatched structural character
    invalid string format
    invalid number format
    invalid array format
    invalid object format
    invalid true format
    invalid false format 
    invalid null format
    